import {KatiFlags} from '../cli/flags';
import {Parser} from '../parser';
import {Stmt, Value} from './ast';
import {SimpleVar, Var, VarOrigin, Vars} from './var';
import {DepVars, makeDep, NamedDepNode, Rule, Symbol} from './dep';
import {exec} from './exec';
import * as fs from 'fs';

export interface MutableLoc {
  filename: string;
  lineno: number;
}

export type Loc = Readonly<MutableLoc>;

export class Scope {
  private undoMap: [string, Var][] = [];

  constructor(private ev: Evaluator) {}

  get(name: string): Var {
    return this.ev.getVar(name);
  }

  set(name: string, var_: Var) {
    this.undoMap.push([name, this.ev.getVar(name)]);
    this.ev.setVar(name, var_);
  }

  undo() {
    this.undoMap.reverse().forEach(([name, var_]) => {
      this.ev.setVar(name, var_);
    });
  }
}

export class Evaluator {
  private flags: KatiFlags;
  private variables: Vars = new Vars();
  private rules: Rule[] = [];
  private ruleVars: Map<Symbol, DepVars> = new Map();
  private _loc: Loc = {filename: '<unknown>', lineno: 0};
  private _eval_depth = 0;

  constructor(flags: KatiFlags) {
    this.flags = flags;
    this.initializeBuiltinVariables();
  }

  private initializeBuiltinVariables(): void {
    // Initialize built-in variables
    this.setSimpleVar('CC', process.env.CC || 'cc', VarOrigin.DEFAULT);
    this.setSimpleVar(
      'CXX',
      process.env.CXX || (process.platform === 'darwin' ? 'c++' : 'g++'),
      VarOrigin.DEFAULT,
    );
    this.setSimpleVar('AR', process.env.AR || 'ar', VarOrigin.DEFAULT);
    this.setSimpleVar('MAKE_VERSION', '4.2.1', VarOrigin.DEFAULT);
    this.setSimpleVar('KATI', 'tskati', VarOrigin.DEFAULT);
    this.setSimpleVar('SHELL', '/bin/sh', VarOrigin.DEFAULT);
    this.setSimpleVar('CURDIR', process.cwd(), VarOrigin.DEFAULT);

    if (this.flags.targets.length > 0) {
      this.setSimpleVar(
        'MAKECMDGOALS',
        this.flags.targets.join(' '),
        VarOrigin.DEFAULT,
      );
    }

    // Copy environment variables
    for (const [key, value] of Object.entries(process.env)) {
      if (value !== undefined) {
        this.setSimpleVar(key, value, VarOrigin.ENVIRONMENT);
      }
    }
  }

  async parseMakefile(makefilePath: string): Promise<void> {
    console.log(`*kati*: Parsing makefile: ${makefilePath}`);

    try {
      const content = fs.readFileSync(makefilePath, 'utf8');
      const statements: Stmt[] = [];
      const parser = new Parser(content, makefilePath, statements);

      parser.parse();

      console.log(
        `*kati*: Parsed ${statements.length} statements from ${makefilePath}`,
      );

      // Evaluate all statements
      for (const stmt of statements) {
        try {
          stmt.eval(this);
        } catch (error) {
          console.error(`*kati*: Error evaluating statement: ${error}`);
          throw error;
        }
      }

      console.log(`*kati*: Successfully evaluated makefile: ${makefilePath}`);
    } catch (error) {
      console.error(`*kati*: Error parsing makefile ${makefilePath}: ${error}`);
      throw error;
    }
  }

  async buildDependencyGraph(targets: string[]): Promise<NamedDepNode[]> {
    console.log(
      `*kati*: Building dependency graph for targets: ${targets.join(', ')}`,
    );

    const nodes = makeDep(this, this.rules, this.ruleVars, targets);

    console.log(`*kati*: Built dependency graph with ${nodes.length} nodes`);
    return nodes;
  }

  async generateNinja(nodes: NamedDepNode[]): Promise<void> {
    console.log(
      `*kati*: [PLACEHOLDER] Generating Ninja build file for ${nodes.length} targets`,
    );

    // TODO: Implement actual Ninja file generation
    const ninjaContent = [
      '# Generated by tskati (TypeScript Kati)',
      '# This is a placeholder implementation',
      '',
      'rule PLACEHOLDER',
      '  command = $cmd',
      '  description = $desc',
      '',
    ];

    for (const {name, node} of nodes) {
      ninjaContent.push(`build ${name}: PLACEHOLDER`);
      ninjaContent.push(`  cmd = ${node.cmds.join(' && ')}`);
      ninjaContent.push(`  desc = Building ${name}`);
      ninjaContent.push('');
    }

    const fs = await import('fs');
    await fs.promises.writeFile('build.ninja', ninjaContent.join('\n'));
    console.log('*kati*: [PLACEHOLDER] Wrote build.ninja');
  }

  async execute(nodes: NamedDepNode[]): Promise<number> {
    console.log(`*kati*: Executing ${nodes.length} targets`);

    try {
      await exec(nodes, this);
      return 0;
    } catch (error) {
      console.error(`*kati*: Execution failed: ${error}`);
      return 1;
    }
  }

  getVar(name: string): Var {
    return this.variables.lookup(name);
  }

  setVar(name: string, var_: Var): void {
    this.variables.assign(name, var_);
  }

  setValue(name: string, value: Value, loc: Loc): void {
    const var_ = new SimpleVar(value.eval(this), VarOrigin.FILE, null, loc);
    this.variables.assign(name, var_);
  }

  set(name: string, value: Var) {
    this.variables.assign(name, value);
  }

  get(name: string): Var {
    return this.variables.lookup(name);
  }

  private setSimpleVar(name: string, value: string, origin: VarOrigin): void {
    const var_ = new SimpleVar(value, origin, null, {
      filename: '<builtin>',
      lineno: 0,
    });
    this.variables.assign(name, var_);
  }

  error(msg: string): never {
    throw new Error(msg);
  }

  lookupVar(name: string): Var {
    return this.variables.lookup(name);
  }

  withScope<T>(fn: (scope: Scope) => T): T {
    const scope = new Scope(this);
    const result = fn(scope);
    scope.undo();
    return result;
  }

  avoid_io(): boolean {
    return this.flags.isDryRun;
  }

  loc(): Loc {
    return this._loc;
  }

  getShell(): string {
    return process.env.SHELL || '/bin/sh';
  }

  getShellFlag(): string {
    return '-c';
  }

  eval_depth(): number {
    return this._eval_depth;
  }

  setLoc(loc: Loc): void {
    this._loc = loc;
  }

  incrementEvalDepth(): void {
    this._eval_depth++;
  }

  decrementEvalDepth(): void {
    this._eval_depth--;
  }

  // Rule management methods
  addRule(rule: Rule): void {
    this.rules.push(rule);
  }

  setRuleVar(target: Symbol, name: Symbol, var_: Var): void {
    let vars = this.ruleVars.get(target);
    if (!vars) {
      vars = new Map<Symbol, Var>();
      this.ruleVars.set(target, vars);
    }
    vars.set(name, var_);
  }

  getRuleVars(target: Symbol): DepVars | null {
    return this.ruleVars.get(target) || null;
  }

  getRules(): Rule[] {
    return [...this.rules];
  }

  getFlags(): KatiFlags {
    return this.flags;
  }
}
