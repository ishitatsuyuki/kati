import {KatiFlags} from '../cli/flags';
import {Parser} from '../parser';
import {Stmt, Value, Literal} from './ast';
import {Vars, Var, SimpleVar, VarOrigin} from './var';
import * as fs from 'fs';

export interface DepNode {
  target: string;
  dependencies: string[];
  commands: string[];
  isPhony: boolean;
}

export interface MutableLoc {
  filename: string;
  lineno: number;
}

export type Loc = Readonly<MutableLoc>;

export class Scope {
  private undoMap: [string, Var][] = [];

  constructor(private ev: Evaluator) {}

  get(name: string): Var {
    return this.ev.getVar(name);
  }

  set(name: string, var_: Var) {
    this.undoMap.push([name, this.ev.getVar(name)]);
    this.ev.setVar(name, var_);
  }

  undo() {
    this.undoMap.reverse().forEach(([name, var_]) => {
      this.ev.setVar(name, var_);
    });
  }
}

export class Evaluator {
  private flags: KatiFlags;
  private variables: Vars = new Vars();
  private rules: Map<string, DepNode> = new Map();
  private _loc: Loc = {filename: '<unknown>', lineno: 0};
  private _eval_depth = 0;

  constructor(flags: KatiFlags) {
    this.flags = flags;
    this.initializeBuiltinVariables();
  }

  private initializeBuiltinVariables(): void {
    // Initialize built-in variables similar to the C++ version
    this.setSimpleVar('CC', process.env.CC || 'cc', VarOrigin.DEFAULT);
    this.setSimpleVar(
      'CXX',
      process.env.CXX || (process.platform === 'darwin' ? 'c++' : 'g++'),
      VarOrigin.DEFAULT,
    );
    this.setSimpleVar('AR', process.env.AR || 'ar', VarOrigin.DEFAULT);
    this.setSimpleVar('MAKE_VERSION', '4.2.1', VarOrigin.DEFAULT);
    this.setSimpleVar('KATI', 'tskati', VarOrigin.DEFAULT);
    this.setSimpleVar('SHELL', '/bin/sh', VarOrigin.DEFAULT);
    this.setSimpleVar('CURDIR', process.cwd(), VarOrigin.DEFAULT);

    if (this.flags.targets.length > 0) {
      this.setSimpleVar(
        'MAKECMDGOALS',
        this.flags.targets.join(' '),
        VarOrigin.DEFAULT,
      );
    }

    // Copy environment variables
    for (const [key, value] of Object.entries(process.env)) {
      if (value !== undefined) {
        this.setSimpleVar(key, value, VarOrigin.ENVIRONMENT);
      }
    }
  }

  async parseMakefile(makefilePath: string): Promise<void> {
    console.log(`*kati*: Parsing makefile: ${makefilePath}`);

    try {
      const content = fs.readFileSync(makefilePath, 'utf8');
      const statements: Stmt[] = [];
      const parser = new Parser(content, makefilePath, statements);

      parser.parse();

      console.log(
        `*kati*: Parsed ${statements.length} statements from ${makefilePath}`,
      );

      // Evaluate all statements
      for (const stmt of statements) {
        try {
          stmt.eval(this);
        } catch (error) {
          console.error(`*kati*: Error evaluating statement: ${error}`);
          throw error;
        }
      }

      console.log(`*kati*: Successfully evaluated makefile: ${makefilePath}`);
    } catch (error) {
      console.error(`*kati*: Error parsing makefile ${makefilePath}: ${error}`);
      throw error;
    }
  }

  async buildDependencyGraph(targets: string[]): Promise<DepNode[]> {
    console.log(
      `*kati*: [PLACEHOLDER] Building dependency graph for targets: ${targets.join(', ')}`,
    );

    const nodes: DepNode[] = [];
    const targetsToProcess = targets.length > 0 ? targets : ['all'];

    for (const target of targetsToProcess) {
      const rule = this.rules.get(target);
      if (rule) {
        nodes.push(rule);
      } else {
        // Create a placeholder rule
        const placeholderRule: DepNode = {
          target,
          dependencies: [],
          commands: [`echo "No rule to make target '${target}'"`],
          isPhony: false,
        };
        nodes.push(placeholderRule);
      }
    }

    return nodes;
  }

  async generateNinja(nodes: DepNode[]): Promise<void> {
    console.log(
      `*kati*: [PLACEHOLDER] Generating Ninja build file for ${nodes.length} targets`,
    );

    // TODO: Implement actual Ninja file generation
    const ninjaContent = [
      '# Generated by tskati (TypeScript Kati)',
      '# This is a placeholder implementation',
      '',
      'rule PLACEHOLDER',
      '  command = $cmd',
      '  description = $desc',
      '',
    ];

    for (const node of nodes) {
      ninjaContent.push(`build ${node.target}: PLACEHOLDER`);
      ninjaContent.push(`  cmd = ${node.commands.join(' && ')}`);
      ninjaContent.push(`  desc = Building ${node.target}`);
      ninjaContent.push('');
    }

    const fs = await import('fs');
    await fs.promises.writeFile('build.ninja', ninjaContent.join('\n'));
    console.log('*kati*: [PLACEHOLDER] Wrote build.ninja');
  }

  async execute(nodes: DepNode[]): Promise<number> {
    console.log(`*kati*: [PLACEHOLDER] Executing ${nodes.length} targets`);

    if (this.flags.isDryRun) {
      console.log('*kati*: [DRY RUN] Would execute:');
      for (const node of nodes) {
        for (const command of node.commands) {
          console.log(`[DRY RUN] ${command}`);
        }
      }
      return 0;
    }

    // TODO: Implement actual command execution
    for (const node of nodes) {
      if (!this.flags.isSilentMode) {
        console.log(`*kati*: Building target: ${node.target}`);
      }

      for (const command of node.commands) {
        if (!this.flags.isSilentMode) {
          console.log(command);
        }

        // TODO: Actually execute the command
        // For now, just simulate execution
        console.log(`*kati*: [PLACEHOLDER] Executed: ${command}`);
      }
    }

    return 0;
  }

  getVar(name: string): Var {
    return this.variables.lookup(name);
  }

  setVar(name: string, var_: Var): void {
    this.variables.assign(name, var_);
  }

  setValue(name: string, value: Value, loc: Loc): void {
    const var_ = new SimpleVar(value.eval(this), VarOrigin.FILE, null, loc);
    this.variables.assign(name, var_);
  }

  set(name: string, value: Var) {
    this.variables.assign(name, value);
  }

  get(name: string): Var {
    return this.variables.lookup(name);
  }

  private setSimpleVar(name: string, value: string, origin: VarOrigin): void {
    const var_ = new SimpleVar(value, origin, null, {
      filename: '<builtin>',
      lineno: 0,
    });
    this.variables.assign(name, var_);
  }

  error(msg: string): never {
    throw new Error(msg);
  }

  lookupVar(name: string): Var {
    return this.variables.lookup(name);
  }

  withScope<T>(fn: (scope: Scope) => T): T {
    const scope = new Scope(this);
    const result = fn(scope);
    scope.undo();
    return result;
  }

  avoid_io(): boolean {
    // TODO: Implement proper IO avoidance logic for ninja generation
    return false;
  }

  loc(): Loc {
    return this._loc;
  }

  getShell(): string {
    return process.env.SHELL || '/bin/sh';
  }

  getShellFlag(): string {
    return '-c';
  }

  eval_depth(): number {
    return this._eval_depth;
  }

  setLoc(loc: Loc): void {
    this._loc = loc;
  }

  incrementEvalDepth(): void {
    this._eval_depth++;
  }

  decrementEvalDepth(): void {
    this._eval_depth--;
  }
}
