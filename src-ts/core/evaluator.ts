import { KatiFlags } from '../cli/flags.js';
import { Parser } from '../parser.js';
import { Stmt, Value, Literal } from './ast.js';
import * as fs from 'fs';

export interface DepNode {
  target: string;
  dependencies: string[];
  commands: string[];
  isPhony: boolean;
}

export interface Loc {
  filename: string;
  lineno: number;
}

export class Scope {
  private undoMap: [string, Value | undefined][] = [];

  constructor(private ev: Evaluator) {}

  get(name: string): Value | undefined {
    return this.ev.get(name);
  }

  set(name: string, val: string) {
    this.undoMap.push([name, this.ev.get(name)]);
    this.ev.setVariable(name, new Literal({ filename: '<scope>', lineno: 0 }, val));
  }

  undo() {
    this.undoMap.reverse().forEach(([name, val]) => {
      if (val === undefined) {
        console.warn("TODO: unset variable.");
      } else {
        this.ev.set(name, val);
      }
    });
  }
}

export class Evaluator {
  private flags: KatiFlags;
  private variables: Map<string, Value> = new Map();
  private rules: Map<string, DepNode> = new Map();
  private _loc: Loc = { filename: '<unknown>', lineno: 0 };
  private _eval_depth: number = 0;

  constructor(flags: KatiFlags) {
    this.flags = flags;
    this.initializeBuiltinVariables();
  }

  private initializeBuiltinVariables(): void {
    // Initialize built-in variables similar to the C++ version
    this.setLiteral('CC', process.env.CC || 'cc');
    this.setLiteral('CXX', process.env.CXX || (process.platform === 'darwin' ? 'c++' : 'g++'));
    this.setLiteral('AR', process.env.AR || 'ar');
    this.setLiteral('MAKE_VERSION', '4.2.1');
    this.setLiteral('KATI', 'tskati');
    this.setLiteral('SHELL', '/bin/sh');
    this.setLiteral('CURDIR', process.cwd());
    
    if (this.flags.targets.length > 0) {
      this.setLiteral('MAKECMDGOALS', this.flags.targets.join(' '));
    }
    
    // Copy environment variables
    for (const [key, value] of Object.entries(process.env)) {
      if (value !== undefined) {
        this.setLiteral(key, value);
      }
    }
  }

  async parseMakefile(makefilePath: string): Promise<void> {
    console.log(`*kati*: Parsing makefile: ${makefilePath}`);
    
    try {
      const content = fs.readFileSync(makefilePath, 'utf8');
      const statements: Stmt[] = [];
      const parser = new Parser(content, makefilePath, statements);
      
      parser.parse();
      
      console.log(`*kati*: Parsed ${statements.length} statements from ${makefilePath}`);
      
      // Evaluate all statements
      for (const stmt of statements) {
        try {
          stmt.eval(this);
        } catch (error) {
          console.error(`*kati*: Error evaluating statement: ${error}`);
          throw error;
        }
      }
      
      console.log(`*kati*: Successfully evaluated makefile: ${makefilePath}`);
      
    } catch (error) {
      console.error(`*kati*: Error parsing makefile ${makefilePath}: ${error}`);
      throw error;
    }
  }

  async buildDependencyGraph(targets: string[]): Promise<DepNode[]> {
    console.log(`*kati*: [PLACEHOLDER] Building dependency graph for targets: ${targets.join(', ')}`);
    
    const nodes: DepNode[] = [];
    const targetsToProcess = targets.length > 0 ? targets : ['all'];
    
    for (const target of targetsToProcess) {
      const rule = this.rules.get(target);
      if (rule) {
        nodes.push(rule);
      } else {
        // Create a placeholder rule
        const placeholderRule: DepNode = {
          target,
          dependencies: [],
          commands: [`echo "No rule to make target '${target}'"`],
          isPhony: false
        };
        nodes.push(placeholderRule);
      }
    }
    
    return nodes;
  }

  async generateNinja(nodes: DepNode[]): Promise<void> {
    console.log(`*kati*: [PLACEHOLDER] Generating Ninja build file for ${nodes.length} targets`);
    
    // TODO: Implement actual Ninja file generation
    const ninjaContent = [
      '# Generated by tskati (TypeScript Kati)',
      '# This is a placeholder implementation',
      '',
      'rule PLACEHOLDER',
      '  command = $cmd',
      '  description = $desc',
      ''
    ];
    
    for (const node of nodes) {
      ninjaContent.push(`build ${node.target}: PLACEHOLDER`);
      ninjaContent.push(`  cmd = ${node.commands.join(' && ')}`);
      ninjaContent.push(`  desc = Building ${node.target}`);
      ninjaContent.push('');
    }
    
    const fs = await import('fs');
    await fs.promises.writeFile('build.ninja', ninjaContent.join('\n'));
    console.log('*kati*: [PLACEHOLDER] Wrote build.ninja');
  }

  async execute(nodes: DepNode[]): Promise<number> {
    console.log(`*kati*: [PLACEHOLDER] Executing ${nodes.length} targets`);
    
    if (this.flags.isDryRun) {
      console.log('*kati*: [DRY RUN] Would execute:');
      for (const node of nodes) {
        for (const command of node.commands) {
          console.log(`[DRY RUN] ${command}`);
        }
      }
      return 0;
    }
    
    // TODO: Implement actual command execution
    for (const node of nodes) {
      if (!this.flags.isSilentMode) {
        console.log(`*kati*: Building target: ${node.target}`);
      }
      
      for (const command of node.commands) {
        if (!this.flags.isSilentMode) {
          console.log(command);
        }
        
        // TODO: Actually execute the command
        // For now, just simulate execution
        console.log(`*kati*: [PLACEHOLDER] Executed: ${command}`);
      }
    }
    
    return 0;
  }

  getVariable(name: string): Value | undefined {
    return this.variables.get(name);
  }

  setVariable(name: string, value: Value): void {
    this.variables.set(name, value);
  }

  set(name: string, value: Value) {
    this.variables.set(name, value);
  }

  get(name: string): Value | undefined {
    return this.variables.get(name);
  }

  private setLiteral(name: string, value: string): void {
    this.variables.set(name, new Literal({ filename: '<builtin>', lineno: 0 }, value));
  }

  error(msg: string): never {
    throw new Error(msg);
  }

  lookupVar(name: string): Value | undefined {
    return this.variables.get(name);
  }

  withScope<T>(fn: (scope: Scope) => T): T {
    const scope = new Scope(this);
    const result = fn(scope);
    scope.undo();
    return result;
  }

  avoid_io(): boolean {
    // TODO: Implement proper IO avoidance logic for ninja generation
    return false;
  }

  loc(): Loc {
    return this._loc;
  }

  getShell(): string {
    return process.env.SHELL || '/bin/sh';
  }

  getShellFlag(): string {
    return '-c';
  }

  eval_depth(): number {
    return this._eval_depth;
  }

  setLoc(loc: Loc): void {
    this._loc = loc;
  }

  incrementEvalDepth(): void {
    this._eval_depth++;
  }

  decrementEvalDepth(): void {
    this._eval_depth--;
  }
}